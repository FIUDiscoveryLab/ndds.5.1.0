/* (c) Copyright, Real-Time Innovations, Inc. 2003-2009. All rights reserved. */
/*
 * @(#)netio_common.h    generated by: makeheader    Sat Nov 23 02:38:30 2013
 *
 *		built from:	common.ifc
 */

#ifndef netio_common_h
#define netio_common_h


  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif
  #ifndef osapi_ntptime_h
    #include "osapi/osapi_ntptime.h"
  #endif
  #ifndef reda_buffer_h
    #include "reda/reda_buffer.h"
  #endif
  #ifndef reda_inlineList_h
    #include "reda/reda_inlineList.h"
  #endif
  #ifndef netio_dll_h
    #include "netio/netio_dll.h"
  #endif
  #ifndef transport_interface_h
    #include "transport/transport_interface.h"
  #endif
  #ifndef cdr_encapsulation_h
    #include "cdr/cdr_encapsulation.h"
  #endif

#ifdef __cplusplus
    extern "C" {
#endif

struct REDAWorker;/* forward declare to appease compiler */

struct RTINetioAddressFilter {
    /*e Address portion of the filter.  Only the bits that correspond to
      the "1" of the mask bit matter.
    */
    NDDS_Transport_Address_t address;
    /*e mask for the address */
    NDDS_Transport_Address_t mask;
};

extern RTINetioDllExport void
RTINetioAddressFilter_print(const struct RTINetioAddressFilter *address,
			    const char *desc, 
			    int indent);

extern RTINetioDllExport
int RTINetioAddressFilter_compare(const struct RTINetioAddressFilter *l, 
				  const struct RTINetioAddressFilter *r);

extern RTINetioDllExport
RTIBool RTINetioAddressFilter_filter(const struct RTINetioAddressFilter *me,
				     const NDDS_Transport_Address_t *address);


#define RTI_NETIO_ADDRESS_INVALID { \
      { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }


#define RTI_NETIO_ADDRESS_FILTER_ANY {\
      RTI_NETIO_ADDRESS_INVALID, \
      RTI_NETIO_ADDRESS_INVALID}


#define RTI_NETIO_ADDRESS_FILTER_UNSPECIFIED { \
      RTI_NETIO_ADDRESS_INVALID, \
      {{0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, \
                0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF}} }


#define RTI_NETIO_ADDRESS_FILTER_LOOPBACK { \
      {{0, 0, 0, 1}}, \
      {{0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, \
                0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF}} }                                                           


#define RTI_NETIO_ADDRESS_FILTER_MULTICAST { \
      {{0xFF,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, \
                0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00}}, \
      {{0xFF,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, \
                0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00}} }                                                                   


#define RTI_NETIO_ADDRESS_FILTER_SITE_LOCAL_UNICAST { \
      {{0xFE,0xC0,0x00,0x00, 0x00,0x00,0x00,0x00, \
                0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00}}, \
      {{0xFF,0xC0,0x00,0x00, 0x00,0x00,0x00,0x00, \
                0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00}} }                                                                     

extern RTINetioDllExport RTIBool
RTINetioAddressFilter_from(struct RTINetioAddressFilter   *me, 
			   const NDDS_Transport_Address_t *address_range_in,
			   int transport_address_bit_count_in);


#define RTI_NETIO_ALIAS_LIST_LENGTH_MAX (128)

struct RTINetioAliasList {
    /*e @brief An NULL terminated string of characters. 
      
        One extra element, to guarantee that it is always 
        terminated by a '\0' character. Thus strncpy()
        can be safely used:
        
        \code
        RTIAliasList aliasList = RTI_NETIO_ALIAS_LIST_DEFAULT;
        strncpy(aliasList.element, sourceAliasString, 
                RTI_NETIO_ALIAS_LIST_LENGTH_MAX);
       \endcode
     */
    char element[RTI_NETIO_ALIAS_LIST_LENGTH_MAX+1]; 
};

extern RTINetioDllExport void 
RTINetioAliasList_init(struct RTINetioAliasList* me);

extern RTINetioDllExport void 
RTINetioAliasList_fromString(struct RTINetioAliasList* me, 
                             const char* stringValueIn);

extern RTINetioDllExport const char* 
RTINetioAliasList_toString(struct RTINetioAliasList* me);

extern RTINetioDllExport RTIBool 
RTINetioAliasList_append(struct RTINetioAliasList* me, 
                         const struct RTINetioAliasList* listIn);

extern RTINetioDllExport RTIBool 
RTINetioAliasList_appendFromString(struct RTINetioAliasList* me, 
                         const char *stringIn);

extern RTINetioDllExport RTIBool
RTINetioAliasList_split(const struct RTINetioAliasList* me, 
                        struct RTINetioAliasList* headOut, 
                        struct RTINetioAliasList* tailOut);

extern RTINetioDllExport RTI_INT32 
RTINetioAliasList_count(const struct RTINetioAliasList* me);

extern RTINetioDllExport RTIBool 
RTINetioAliasList_match(struct RTINetioAliasList* candidateListIn, 
                        struct RTINetioAliasList* targetListIn);

extern RTINetioDllExport int 
RTINetioAliasList_compare(const struct RTINetioAliasList *l,
			  const struct RTINetioAliasList *r);

extern RTINetioDllExport void 
RTINetioAliasList_print(const struct RTINetioAliasList *data, 
			const char *desc, int indent);


#define RTI_NETIO_ALIAS_LIST_SEPARATOR   ','


#define RTI_NETIO_ALIAS_LIST_DEFAULT { {\
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0 /* Guarantee NULL terminated */ \
}}


#define RTI_NETIO_ALIAS_LIST_UDPv4 { {\
    'u', 'd', 'p', 'v', '4', 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0 /* Guarantee NULL terminated */ \
}}


#define RTI_NETIO_ALIAS_LIST_UDPv6 { {\
    'u', 'd', 'p', 'v', '6', 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0 /* Guarantee NULL terminated */ \
}}


#define RTI_NETIO_ALIAS_LIST_INTRA { {\
    'i', 'n', 't', 'r', 'a', 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0 /* Guarantee NULL terminated */ \
}}


#define RTI_NETIO_ALIAS_LIST_SHMEM { {\
    's', 'h', 'm', 'e', 'm', 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0 /* Guarantee NULL terminated */ \
}}


#define RTI_NETIO_ALIAS_LIST_STARFABRIC { {\
    's', 't', 'a', 'r', 'f', 'a', 'b', 'r', 'i', 'c', \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0 /* Guarantee NULL terminated */ \
}}


#define RTI_NETIO_ALIAS_LIST_INTRA_UDPv4 { {\
    'i', 'n', 't', 'r', 'a', RTI_NETIO_ALIAS_LIST_SEPARATOR, 'u', 'd', 'p', 'v', \
    '4', 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0 /* Guarantee NULL terminated */ \
}}


#define NETIO_LOCATOR_ENCAPSULATION_COUNT_MAX   (8)

struct RTINetioLocator {
    /*e
      @brief A transport class.
     */
    NDDS_Transport_ClassId_t transport;
    
    /*e
      @brief An address. Must be unique for the transport class
      in the domain. 
     */
    NDDS_Transport_Address_t address;
    
    /*e
      @brief A port number.
     */
    NDDS_Transport_Port_t port;  

    /*e
      @brief Number of encapsulations 
    */
    RTI_UINT32 encapsulationCount;

    /*e
      @brief encapsulation IDs
     */
    RTIEncapsulationId encapsulations[NETIO_LOCATOR_ENCAPSULATION_COUNT_MAX];
};

extern RTINetioDllExport
void RTINetioLocator_from(struct RTINetioLocator *me, 
		     NDDS_Transport_ClassId_t             transportIn,
		     const NDDS_Transport_Address_t      *addressIn,
		     NDDS_Transport_Port_t                portIn);

extern RTINetioDllExport 
void RTINetioLocator_print(const struct RTINetioLocator *me, 
			   const char *desc,
			   int indent);

extern RTINetioDllExport 
void RTINetioLocator_printODT(void *me, 
			   const char *desc,
			   int indent);


#define RTI_NETIO_LOCATOR_STRING_BUFFER_SIZE \
    RTI_NETIO_ALIAS_LIST_LENGTH_MAX + 3 /*strlen("://")*/ + \
    NDDS_TRANSPORT_ADDRESS_STRING_BUFFER_SIZE + 6/*strlen(":99999")*/ + 1

/*i \ingroup RTINetioLocatorType
  @brief Converts a locator into a string with the following format:
  
  <alias>://<address>:<port>
  
  The alias parameter is optional. If not provided the transport class
  is printed instead.
*/
RTIBool RTINetioLocator_toString(
    const struct RTINetioLocator *me, 
    const struct RTINetioAliasList * aliasList,
    char * buffer,
    RTI_UINT32 bufferSize);

/*e \ingroup RTINetioLocatorType
  @see REDAOrderedDataTypeCompareFunction
*/
extern RTINetioDllExport
int RTINetioLocator_compare(const struct RTINetioLocator *l, 
			    const struct RTINetioLocator *r);


/*i \ingroup RTINetioLocatorType
  @brief Locator compare, with encapsulation
*/
extern RTINetioDllExport
int RTINetioLocator_compareWithEncapsulationODT(void *l, void *r);


/*e \ingroup RTINetioLocatorType
  @brief Locator compare, with encapsulation
*/
extern RTINetioDllExport
int RTINetioLocator_compareWithEncapsulation(const struct RTINetioLocator *l, 
                                             const struct RTINetioLocator *r);


/*e \ingroup RTINetioLocatorType
*/
extern RTINetioDllExport
int RTINetioLocator_compareI(const struct RTINetioLocator *l, 
                             const struct RTINetioLocator *r,
                             RTIBool compareEncapsulations);


/*e \ingroup RTINetioLocatorType
*/
extern RTINetioDllExport
int RTINetioLocator_compare(const struct RTINetioLocator *l, 
                             const struct RTINetioLocator *r);


/*e \ingroup RTINetioLocatorType
*/
extern RTINetioDllExport
void RTINetioLocator_addEncapsulations(
                    struct RTINetioLocator *me, 
                    int encapsulationCount,
                    RTIEncapsulationId *encapsulations,
                    RTIBool *foundMoreThanProvidedFor);


/*e \ingroup RTINetioLocatorType
  \brief Invalid Locator. 
    
  Used to initialize stack variable, as in
  \code
  RTINetioLocator myLocator = RTI_NETIO_LOCATOR_INVALID;
  \endcode
*/

#define RTI_NETIO_LOCATOR_INVALID { \
  NDDS_TRANSPORT_CLASSID_INVALID, /* transportClass */ \
  RTI_NETIO_ADDRESS_INVALID, /* address */ \
  0, /* port */ \
  0, /* encapsulationCount */ \
  {0,0,0,0,0,0,0,0}, /* encapsulationIDs */ \
  }


/*e \ingroup RTINetioLocatorType
  A way to specify a list of locators, linked together with REDAInlineList
 */
struct RTINetioLocatorInlineNode {
    struct REDAInlineListNode parent;
    struct RTINetioLocator self;
};


struct REDAFastBufferPool;

/*e \ingroup RTINetioLocatorType
 */
extern RTINetioDllExport struct RTINetioLocatorInlineNode*
RTINetioLocatorInlineList_findEA(struct REDAInlineList* me,
				 const struct RTINetioLocator* locatorIn);


/*e \ingroup RTINetioLocatorType
 */
extern RTINetioDllExport struct RTINetioLocatorInlineNode*
RTINetioLocatorInlineList_addEA(struct REDAInlineList* me,
				struct REDAFastBufferPool* nodePoolIn,
				const struct RTINetioLocator* locatorIn);


/*e \ingroup RTINetioLocatorType
 */
extern RTINetioDllExport void
RTINetioLocatorInlineList_removeEA(struct REDAInlineList* me,
				   struct REDAFastBufferPool* nodePoolIn,
				   const struct RTINetioLocator* locatorIn);


/*e \ingroup RTINetioLocatorType
 */
extern RTINetioDllExport void
RTINetioLocatorInlineList_finalizeEA(struct REDAInlineList* me,
				     struct REDAFastBufferPool* nodePoolIn);



/* ================================================================= */
/*                         Locator Info                              */
/* ================================================================= */
/*e \defgroup RTINetioLocatorInfoType RTINetioLocatorInfo
  \ingroup RTINetioCommonComponent
  \brief Convenience for defining RTIEntryport and RTIDestination types.

  Ensures that the information required to specify a destination or
  entryport is kept togethr in single structure.

  Also, ensures that there is one common place where additiona fileds
  can be added (or removed) to sepcify a destination and/or entryport.
*/

/*e \ingroup RTINetioLocatorInfoType
  \brief Base type for an RTIDestination or an RTIEntryport.   
*/
struct RTINetioLocatorInfo { 
    /*e @brief A locator. */
    struct RTINetioLocator locator;

    /*e @brief Transport specific priority */
    int transport_priority;

    /*e @brief Alias list, that specifies the list of transport plugin 
      instances that should handle the locator.      
    */
    struct RTINetioAliasList aliasList;
};


/*e \ingroup RTINetioLocatorInfoType
  \brief For logging
  @see REDAOrderedDataTypePrintFunction
*/
extern RTINetioDllExport 
void RTINetioLocatorInfo_print(const struct RTINetioLocatorInfo *me, 
			       const char *desc,
			       int indent);


/*e \ingroup RTINetioLocatorInfoType
  @see REDAOrderedDataTypeCompareFunction
*/
extern RTINetioDllExport
int RTINetioLocatorInfo_compare(const struct RTINetioLocatorInfo *l, 
				const struct RTINetioLocatorInfo *r);


/*e \ingroup RTINetioLocatorInfoType
  @brief Initialize a locator info from its constituents.
  
  @pre Each member in the parameter list must be non-NULL.

*/
extern RTINetioDllExport
void RTINetioLocatorInfo_from(struct RTINetioLocatorInfo *me, 
                         NDDS_Transport_ClassId_t        transportIn,
                         const NDDS_Transport_Address_t *addressIn,
                         NDDS_Transport_Port_t           portIn,
                         int transport_priorityIn,
                         const char* stringAliasListIn);



/*e \ingroup RTINetioLocatorInfoType
  \brief A value to initialize a variable on the stack.
 */

#define RTI_NETIO_LOCATOR_INFO_DEFAULT {        \
    RTI_NETIO_LOCATOR_INVALID, /* Locator */    \
    NDDS_TRANSPORT_PRIORITY_DEFAULT, /* transport priority */  \
    RTI_NETIO_ALIAS_LIST_DEFAULT /* aliasList */ }


/*e \ingroup RTINetioLocatorInfoType
  \brief A value to initialize a variable on the stack.
 */

#define RTI_NETIO_LOCATOR_INFO_INTRA {         \
    { NDDS_TRANSPORT_CLASSID_INTRA,         \
      RTI_NETIO_ADDRESS_INVALID, 0 }, \
    NDDS_TRANSPORT_PRIORITY_DEFAULT, /* transport priority */  \
    RTI_NETIO_ALIAS_LIST_INTRA /* aliasList */ }


/*e \ingroup RTINetioLocatorInfoType
  \brief A value to initialize a variable on the stack.
 */

#define RTI_NETIO_LOCATOR_INFO_SHMEM {        \
    { NDDS_TRANSPORT_CLASSID_SHMEM, \
      RTI_NETIO_ADDRESS_INVALID, 0 }, \
    NDDS_TRANSPORT_PRIORITY_DEFAULT, /* transport priority */  \
    RTI_NETIO_ALIAS_LIST_SHMEM /* aliasList */ }



/*e \ingroup RTINetioLocatorInfoType
  \brief A value to initialize a variable on the stack.
 */

#define RTI_NETIO_LOCATOR_INFO_UDPv4 {        \
    { NDDS_TRANSPORT_CLASSID_UDPv4, \
      RTI_NETIO_ADDRESS_INVALID, 0 }, \
    NDDS_TRANSPORT_PRIORITY_DEFAULT, /* transport priority */  \
    RTI_NETIO_ALIAS_LIST_UDPv4 /* aliasList */ }


/*e \ingroup RTINetioLocatorInfoType
  \brief A value to initialize a variable on the stack.
 */

#define RTI_NETIO_LOCATOR_INFO_UDPv6 {        \
    { NDDS_TRANSPORT_CLASSID_UDPv6, \
      RTI_NETIO_ADDRESS_INVALID, 0 }, \
    NDDS_TRANSPORT_PRIORITY_DEFAULT, /* transport priority */  \
    RTI_NETIO_ALIAS_LIST_UDPv6 /* aliasList */ }


/* ================================================================= */
/*                         Message Received                          */
/* ================================================================= */
/*e \defgroup RTINetioMessageClass RTINetioMessage
  \ingroup RTINetioCommonComponent
  \brief Class to represent a received message.
*/

/*e \ingroup RTINetioMessageClass

  \brief Notify that we are done with the received message.

  It is possible that high performance transports lend their internal buffer
  to higher layer to avoid copying memory.  In that case, it is crucial that
  the higher layer releases the memory as soon as read is done, to avoid
  running out of memory in the transport.

  Implementation that allow multiple threads to process messages
  sent to 1 ReceiveResource (as returned by
  NDDS_Transport_create_recvresource_fnc_rEA) must guarantee
  thread safety if the same param argument is doled out to those
  receiver threads.  That is, the following implementations need not
  provide MT safety:
  <UL>
  <LI>Those that do not need this implementation (of course!)
  <LI>Those for whom the param argument does not resolve to a resource
  that will be accessed concurrently.
  <LI>Those for whom the param argument DOES resolve to a resource
  that will be accessed concurrently, but which is internally MT safe.
  <\UL>

  Currently, due to difficulties in requiring a transport to guarantee the 
  thread safety of this function, we also require that the calling of this 
  function always be within the same context as the thread that made the call 
  to the RTINetioReceiver_receiveFast() function.  Furthermore, this function
  must be called before calling RTINetioReceiver_disownResource().

  This means that a compliant implementation of a receive thread will exhibit
  the following sequence of calls made using the netio API:
  \code
      RTINetioReceiver_receiveFast()
      RTINetioReceiver_returnLoan()
      RTINetioReceiver_disownResource()
  \endcode
  However, in the future, to support such concepts as a zero-copy transport,
  this requirement will need to be removed such that the
  return_loaned_buffer function may be called elsewhere as needed.  At
  that time, some transports may need to be strengthened and modified
  to meet this requirement. 
  
  @internal See bug #8205 for more details.
*/

/*e \ingroup RTINetioMessageClass 
  \brief Information about the received message, to be set
  by the receiving transport.

  @see RTINetioMessage_return_loaned_buffer
*/
struct RTINetioMessage {
    NDDS_Transport_Message_t message;
    struct RTINtpTime timestamp;
};



#define RTI_NETIO_MESSAGE_INVALID  { NDDS_TRANSPORT_MESSAGE_INVALID, \
                                     RTI_NTP_TIME_ZERO }

/* ================================================================= */

/* ================================================================= */
/*                  Installed Transports Properties                  */
/* ================================================================= */
struct RTINetioTransportInfo {
   NDDS_Transport_ClassId_t classid;
   RTI_INT32 messageSizeMax;
};



#ifdef __cplusplus
    }	/* extern "C" */
#endif

  #include "netio/netio_common_impl.h"


/* end of $Id: common.ifc,v 1.31 2013/09/11 16:57:46 fernando Exp $ */
#endif /* netio_common_h */
