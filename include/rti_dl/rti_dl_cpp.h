/*
 * @(#)rti_dl_cpp.h    generated by: makeheader    Sat Nov 23 02:41:02 2013
 *
 *		built from:	cpp.ifcxx
 */

#ifndef rti_dl_cpp_h
#define rti_dl_cpp_h



#ifndef dds_cpp_domain_h
    #include "dds_cpp/dds_cpp_domain.h"
#endif

#ifndef rti_dl_dll_cpp_h
  #include "rti_dl/rti_dl_dll_cpp.h"
#endif

#ifndef rti_dl_c_h
    #include "rti_dl/rti_dl_c.h"
#endif

class RTI_DLDistLogger; /* Forward declaration */

class RTIDLCPPDllExport RTI_DLOptions{
    friend class RTI_DLDistLogger;
public:
    /*e
     *  \brief Default constructor
     * 
     *  Allocates memory for a RTI_DLOptions class and sets the default values needed to create the DL.
     *  \see    ~RTI_DLOptions()
     */
    RTI_DLOptions();

    /*e
     *  \brief Default destructor
     * 
     *  Frees RTI_DLOptions class. Checks whether the pointer exists or not.
     */
    ~RTI_DLOptions();

    /*e
     *  \brief Gets current C DomainParticipant.
     *
     *  If this field is not null, then this is the internal C
     *  DomainParticipant that will be used to create DDS entities 
     *  (Topics, Publishers, Subscribers, DataWriters, & DataReaders) needed
     *  by the Distributed Logger. The default value is NULL.
     *  \return  Pointer to the DDS_DomainParticipant contained in the class.
     */
    DDS_DomainParticipant * getCDomainParticipantI();

    /*e 
     *  \brief Sets current DomainParticipant.
     *
     *  \param [in] domainParticipant   Pointer to a valid DDS_DomainParticipant
     *  \post   Memory must be released by the user after finalizing DL.
     */
    DDS_ReturnCode_t setDomainParticipant(DDSDomainParticipant * domainParticipant);

    /*e
     *  \brief Sets current DomainParticipant.
     *
     * If true, remote administration Topics will be created and
     * used. If false, they will not be created. The default value
     * is true.
     * \return true if the Remote Administration is enabled. Otherwise false.
     */
    bool isRemoteAdministrationEnabled();

    /*e
     *  \brief Enables or disables remote administration
     *
     * Sets remote administration of the Topics to the value passed as
     * parameter.
     *  \param [in] enabled Boolean indicating new remote administration value.
     */
    DDS_ReturnCode_t setRemoteAdministrationEnabled(bool enabled);

    /*e 
     * \brief Gets the log filter level.
	 *
     * Supported Filter Levels: See the IDL file provided with Distributed Logger
     * (ndds.\<version\>/resource/rtidistlogger/idl/rtidistlog.idl)
	 *  
     * The default value is RTI_DL_TRACE_LEVEL.
	 * See setFilterLevel() for more information on filter levels.
	 *
     * \return integer containing the log filter level of the options.
     */
    int getFilterLevel();

    /*e 
     * \brief Sets the log filter level.
	 *
     * Filtering controls what type of log messages are sent.
	 * This enables filtering on the \em sending side (in the application using 
     * Distributed Logger). You can also enable filtering on the \em receiving side 
     * (such as in a tool that receives log messages, like RTI Admin Console or RTI Monitor).
     *
     * Supported Filter Levels: See the IDL file provided with Distributed Logger
     * (file: ndds.\<version\>/resource/rtidistlogger/idl/rtidistlog.idl).
	 * The default value is RTI_DL_TRACE_LEVEL.
	 * In the IDL file, there are language-specific bindings.
     * Prepend the appropriate binding to the filter level shown in the IDL. 
     * For example, one of the filter levels in the IDL is INFO_LEVEL. 
     * To refer to this filter level in C++, use RTI_DL_INFO_LEVEL.
     *
     * Log messages, up to and including the specified filter level, will pass through the filter and 
     * be sent on the network. For example, the WARNING level allows log messages up to and including 
     * the WARNING level (FATAL, SEVERE, ERROR, and WARNING) to be sent; any other 
	 * log messages with numerically higher filter levels (INFO, DEBUG, and TRACE) will be 
	 * filtered out and not sent. 
     *
     * \param [in] filterLevel   The log filter level of the options (see above).
     * \return     Error code.   DDS_RETCODE_OK if everything goes as planned.
	 *
     * The following table shows how Connext log levels map to Distributed Logger log filter levels. 
     * Not all Distributed Logger levels appear in this table because   
     * there is not a one-to-one mapping between Connext and Distributed Logger levels (there are 
     * more levels in Distributed Logger).
     *
     * <CENTER><TABLE>
     * <CAPTION><EM>Filter Levels</EM></CAPTION>      
     * <TR>
     * <TH> <STRONG> </STRONG> Connext </TH>
     * <TH> <STRONG> Distributed Logger </STRONG> </TH>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_ERROR</TD>
     *    <TD>RTI_DL_ERROR_LEVEL</TD>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_WARNING</TD>
     *    <TD>RTI_DL_WARNING_LEVEL</TD>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_STATUS_LOCAL</TD>
     *    <TD>RTI_DL_NOTICE_LEVEL</TD>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_STATUS_REMOTE</TD>
     *    <TD>RTI_DL_INFO_LEVEL</TD>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_DEBUG</TD>
     *    <TD>RTI_DL_DEBUG_LEVEL</TD>
     * </TR>
     * </TABLE></CENTER> 
     */
    DDS_ReturnCode_t setFilterLevel(int filterLevel);

    /*e
     *  \brief Gets the current domain id
     *
     * The DDS domain id to be used. This value is only used if 
     * domainParticipant is NULL. The default value is 0.
     *  \return Integer containing the current DDS domain id.
     */
    int getDomainId();

    /*e 
     *  \brief Sets the current domain id
     *
     * The DDS domain id to be used only if 
     * domainParticipant is NULL.
     *  \param [in] domainId Int representing a DDS domain id. Max value 250
     */    
    DDS_ReturnCode_t setDomainId(int domainId);

    /*e
     *  \brief Gets the Qos Library
     * The QoS library name to use when creating DDS entities. It is up to the
     * application to ensure that this library is available at runtime for the 
     * Distributed Logger to use. The default value is "".
     *  \return String containing the current Qos Library.
     */
    char *getQosLibrary();

    /*e
     *  \brief Sets the Qos Library
     * The QoS library name to use when creating DDS entities. It is up to the
     * application to ensure that this library is available at runtime for the 
     * Distributed Logger to use. The default value is "".
     *  \param [in] qosLibrary String containing the new Qos Library.
     */
    DDS_ReturnCode_t setQosLibrary(const char *qosLibrary);

    /*e
     *  \brief Gets the Qos Profile
     *
     * The QoS profile name to use when creating DDS entities. It is up to the
     * application to ensure that this profile is available at runtime for the 
     * Distributed Logger to use. The default value is "".
     *  \return String containing the current Qos Profile.
     */
    char *getQosProfile();

    /*e
     *  \brief Sets the Qos Profile
     * The QoS profile name to use when creating DDS entities. It is up to the
     * application to ensure that this profile is available at runtime for the 
     * Distributed Logger to use. 
     *  \param [in] qosProfile String containing the new Qos Profile.
     */
    DDS_ReturnCode_t setQosProfile(const char *qosProfile);

   /*e
    *  \brief Gets the maximum queue size
    *
    * This field controls the size of the queue used to temporarily store log
    * messages written from the application until they can be written out to
    * DDS. The default value is RTI_DL_DEFAULT_QUEUE_SIZE.
    *  \return Integer containing the current maximum queue size.
    */
    int getQueueSize();
   /*e
     *  \brief Sets the maximum queue size
     *
     * This field controls the size of the queue used to temporarily store log
     * messages written from the application until they can be written out to
     * DDS. The default value is RTI_DL_DEFAULT_QUEUE_SIZE.
     *  \param [in] queueSize Integer containing the new maximum queue size.
     */
    DDS_ReturnCode_t setQueueSize(int queueSize);

    /*e
     * \brief Get the thread settings of the publishing thread.
     *
     * This field contains general settings of the publishing thread in 
     * Distributed Logger, like the thread priority, the stack size and other
     * settings.
     * \return threadPriority Integer containing the current thread priority.
     */
    struct DDS_ThreadSettings_t * getThreadSettings();

    /*e
     * \brief Set the thread settings of the publishing thread.
     *
     * This parameter is used to control thread parameters, like priority, stack
     * size and other settings. 
     * \param [in] threadSettings A valid DDS_ThreadSettings_t struct with the
     * settings for Distributed Logger's write thread.
     */
    DDS_ReturnCode_t setThreadSettings(const struct DDS_ThreadSettings_t * threadSettings);

    /*e
     * \brief Gets the application kind
     *
     * This char *is sent along on the state Topic and can help identify
     * different applications within a system. You can use this field however
     * you think it will help you most. The default value is "".
     *  \return String containing the current application kind.
     */
    char *getApplicationKind();

    /*e
     * \brief Sets the application kind
     *
     * This string is sent along on the state Topic and can help identify
     * different applications within a system. You can use this field however
     * you think it will help you most.
     *  \param [in] applicationKind String containing the new application kind.
     */
    DDS_ReturnCode_t setApplicationKind(const char *applicationKind);
    
    /*e 
     * \brief Gets the current value of echoToStdout
     *
     * If true, Distributed Logger prints the log messages recieved to the 
     * stdout. The default value is FALSE.
     *  \return Boolean to the current echoToStdout value
     */
    bool getEchoToStdout();

    /*e
     * \brief Sets the value of echoToStdout
     *
     * If true, Distributed Logger prints the log messages received to the 
     * stdout. The default value is FALSE.
     *  \param [in] echoToStdout New value of set self.echoToStdout.
     */
    DDS_ReturnCode_t setEchoToStdout(bool echoToStdout);

private:
    /*i
     * \brief This variable contains the real options.
     *
     *  The RTI_DLOptions class is just a wrapper to the C implementation,
     * so this variable, created in the default constractor, is the one
     * containing the information. Check C Documentation for further details.
     */
    struct RTI_DL_Options *_impl;

    /*i
     * \brief Wrapping constructor.
     * Specific constructor that uses already created configuration options.
     * Its visibility is private, and it's oriented for internal usage.
     */
    RTI_DLOptions(struct RTI_DL_Options * options);
};

class RTIDLCPPDllExport RTI_DLUtility {
public:
    /*e \ingroup RTI_DL_Utility
     *  \brief Block the calling thread for the specified duration
     *
     * Note that the achievable resolution of sleep is OS-dependent.
     * That is, do not assume that you can sleep for 1 ms just
     * because you can specify a 1-ms sleep duration via the API.
     * The sleep resolution on most operating systems is usually 10 ms or greater.
     *
     * \param [in] msec Sleep duration in milliseconds.
     */
    static void sleep(int msec);
};

class RTIDLCPPDllExport RTI_DLDistLogger {
private:
    /*i
     * \brief This variable contains the real DL.
     *
     *  The RTI_DLDistLogger class is just a wrapper to the C implementation,
     * so this variable, created in the default constractor, is the one
     * containing the information. Check C Documentation for further details.
     */
    struct RTI_DL_DistLogger *_impl;

    /*i
     * \brief DL singleton.
     *
     *  The RTI_DLDistLogger is a singleton. This static variable is created
     *  the first time getInstance() is called. It uses the default
     *  options unless setOptions is called BEFORE creating the DL.
     */
    static RTI_DLDistLogger *instance;

    /*i
     * \brief Default constructor
     *
     * Creates the singleton. 
     * It's called when getInstance is called and _impl is NULL.
     */
    RTI_DLDistLogger();

    /*i
     * \brief Default destructor
     *
     * Destroys the singleton. 
     * It's called when finalizeInstance is called.
     */
    ~RTI_DLDistLogger();
                
public:
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Provides access to the RTI_DL_DistLogger singleton.
     *
     * This method provides access to the singleton instance of the RTI_DL_DistLogger. If
     * the instance does not exist it will be created. Note that no change in
     * options is allowed after the singleton is created.
     * \return The singleton instance of the RTI_DL_DistLogger.
     */
    static RTI_DLDistLogger * getInstance();

    /*e \ingroup RTI_DL_DistLogger
     *  \brief Sets the filter level for the singleton.
     *
     * Filtering controls what type of log messages are sent.
     * This enables filtering on the \em sending side (in the application using 
     * Distributed Logger). You can also enable filtering on the \em receiving side 
     * (such as in a tool that receives log messages, like RTI Admin Console or RTI Monitor).
     *
     * Supported Filter Levels: See the IDL file provided with Distributed Logger
     * (file: ndds.\<version\>/resource/rtidistlogger/idl/rtidistlog.idl).
     * The default value is RTI_DL_TRACE_LEVEL.
     *
     * In the IDL file, there are language-specific bindings.
     * Prepend the appropriate binding to the filter level shown in the IDL. 
     * For example, one of the filter levels in the IDL is INFO_LEVEL. 
     * To refer to this filter level in C++, use RTI_DL_INFO_LEVEL.
     *
     * Log messages up to and including the specified filter level will pass through the filter and 
     * be sent on the network. For example, the WARNING level allows log messages up to and including 
     * the WARNING level (FATAL, SEVERE, ERROR, and WARNING) to be sent; any other 
     * log messages with numerically higher filter levels (INFO, DEBUG, and TRACE) will be 
     * filtered out and not sent. 
     *
     *  \param [in] newLevel    The new filter level.
     *
     *  \return     Error code. DDS_RETCODE_OK if everything goes as planned.
     *
     * The following table shows how Connext log levels map to Distributed Logger log filter levels. 
     * Not all Distributed Logger levels appear in this table because   
     * there is not a one-to-one mapping between Connext and Distributed Logger levels (there are 
     * more levels in Distributed Logger).
     *
     * <CENTER><TABLE>
     * <CAPTION><EM>Filter Levels</EM></CAPTION>      
     * <TR>
     * <TH> <STRONG> </STRONG> Connext </TH>
     * <TH> <STRONG> Distributed Logger </STRONG> </TH>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_ERROR</TD>
     *    <TD>RTI_DL_ERROR_LEVEL</TD>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_WARNING</TD>
     *    <TD>RTI_DL_WARNING_LEVEL</TD>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_STATUS_LOCAL</TD>
     *    <TD>RTI_DL_NOTICE_LEVEL</TD>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_STATUS_REMOTE</TD>
     *    <TD>RTI_DL_INFO_LEVEL</TD>
     * </TR>
     * <TR>
     *    <TD>NDDS_CONFIG_LOG_LEVEL_DEBUG</TD>
     *    <TD>RTI_DL_DEBUG_LEVEL</TD>
     * </TR>
     * </TABLE></CENTER> 
     *
     */
    DDS_ReturnCode_t setFilterLevel(DDS_Long newLevel);

    /*e \ingroup RTI_DL_DistLogger
     *  \brief Sets the default options for the RTI_DL_DistLogger. 
     *
     *  Sets the RTI_DL_Options for the singleton.
     *  \param [in]     options     The new options.
     *  \pre    self must be NULL.
     *  \return     RTI_TRUE if everything went as planned.
     */
    static bool setOptions(RTI_DLOptions& options);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Sets PrintFormat of the RTI Logger. 
     *
     *  Modifies the RTI Logger PrintFormat to match logPrintFormat.

     *  \param [in]     logPrintFormat     The new PrintFormat.
     *  \return     RTI_TRUE if everything went as planned.
     */
    bool setRTILoggerPrintFormat(NDDS_Config_LogPrintFormat logPrintFormat);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Updates the LogCategory and the LogVerbosity in the RTI Logger. 
     *
     *  This method is mostly a pass-through to the appropriate call in the RTI
     *  DDS library but it also has the benefit of keeping the state of the 
     *  logger in synch with this setting in the library (there is no other way
     *  to do so).

     *  \param [in]     category    The category for which to set the verbosity.
     *  \param [in]     verbosity   The new verbosity level for the category.
     */
    void setRTILoggerVerbosityByCategory(NDDS_Config_LogCategory category, 
            NDDS_Config_LogVerbosity verbosity);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a message at the specified level and with the specified category.
     *

     *  \param [in] logLevel    The level of the log message.
     *  \param [in] message     The message to log.
     *  \param [in] category    The category of the log message.
     */
    void logMessageWithLevelCategory(int logLevel, const char *message, const char *category);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a fatal message
     *
     *  The message recieved is logged using  the default category and the 
     *  RTI_DL_FATAL_LEVEL as log level.

     *  \param [in] message     The message to log.
     */
    void fatal(const char *message);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a severe message
     *
     *  The message recieved is logged using  the default category and the 
     *  RTI_DL_SEVERE_LEVEL as log level.

     *  \param [in] message     The message to log.
     */
    void severe(const char *message);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a error message
     *
     *  The message recieved is logged using  the default category and the 
     *  RTI_DL_ERROR_LEVEL as log level.

     *  \param [in] message     The message to log.
     */
    void error(const char *message);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a warning message
     *
     *  The message recieved is logged using  the default category and the 
     *  RTI_DL_WARNING_LEVEL as log level.

     *  \param [in] message     The message to log.
     */
    void warning(const char *message);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a notice message
     *
     *  The message recieved is logged using  the default category and the 
     *  RTI_DL_NOTICE_LEVEL as log level.

     *  \param [in] message     The message to log.
     */
    void notice(const char *message);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a info message
     *
     *  The message recieved is logged using  the default category and the 
     *  RTI_DL_INFO_LEVEL as log level.

     *  \param [in] message     The message to log.
     */
    void info(const char *message);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a debug message
     *
     *  The message recieved is logged using  the default category and the 
     *  RTI_DL_DEBUG_LEVEL as log level.

     *  \param [in] message     The message to log.
     */
    void debug(const char *message);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a trace message
     *
     *  The message recieved is logged using  the default category and the 
     *  RTI_DL_TRACE_LEVEL as log level.

     *  \param [in] message     The message to log.
     */
    void trace(const char *message);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Logs a message
     *
     *  The message recieved is logged using  the default category and the 
     *  given log level.

     *  \param [in] logLevel    The level of the log message.
     *  \param [in] message     The message to log.
     */
    void log(int logLevel, const char *message);
    
    /*e \ingroup RTI_DL_DistLogger
     *  \brief Finalizes and delete the RTI_DL_DistLogger singleton. 
     *
     *  Unset the connections with DDS, frees memory and set singleton to NULL
     *  \return     Code error. DDS_RETCODE_OK if everything went as planned.
     */
    void finalizeInstance();

};

#endif /* rti_dl_cpp_h */
